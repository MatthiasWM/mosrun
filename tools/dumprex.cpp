/*
 dumprex - Extract packages from a NewtonOS Rex file.
 Copyright (C) 2013-2020  Matthias Melcher
 Copyright (C) 2022 Victor Rehorst

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

 The author can be contacted at mosrun AT matthiasm DOT com.
 The latest source code can be found at https://github.com/MatthiasWM/mosrun
 */


#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <arpa/inet.h>
#include <string.h>
#include <libgen.h>
#include <stdint.h>


void *gRex = nullptr;
size_t gRexSize = 0;

extern int relocatePkg(uint8_t *pkg, uint32_t oldAddress, uint32_t newAddress);


uint32_t rexGetU32(size_t offset)
{
    if (offset+4>gRexSize)
        return 0xFEEDFEED;
    uint32_t ret = 0;
    ret |= ((uint8_t*)gRex)[offset+0]<<24;
    ret |= ((uint8_t*)gRex)[offset+1]<<16;
    ret |= ((uint8_t*)gRex)[offset+2]<<8;
    ret |= ((uint8_t*)gRex)[offset+3];
    return ret;
}


int writeHexForC(const char *basedir, const char *fname, uint32_t ix, const char *ext, uint32_t offset, uint32_t length)
{
    char filename[2048];

    // write binary
    snprintf(filename, sizeof(filename), "%s/%s%d%s", basedir, fname, ix, ext);
    FILE *f = fopen(filename, "wb");
    if (!f) {
        printf("DumpRex: can't open binary file \"%s\" for writing:\n%s\n", filename, strerror(errno));
        return -1;
    }
    ::fwrite((uint8_t*)gRex+offset, length, 1, f);
    ::fclose(f);

    // write hexdump
    snprintf(filename, sizeof(filename), "%s/%s%d%s.cpp", basedir, fname, ix, ext);
    f = fopen(filename, "wb");
    if (!f) {
        printf("DumpRex: can't open cpp file \"%s\" for writing:\n%s\n", filename, strerror(errno));
        return -1;
    }
    fprintf(f, "//\n// Generated by DumpRex.\n//\n\n");
    fprintf(f, "const uint8_t %s%d[] = {\n", fname, ix);
    uint8_t *part = (uint8_t*)gRex + offset;
    for (size_t i=0; i<length; i+=16) {
        fprintf(f, "    ");
        for (size_t j=0; j<16; j++) {
            size_t addr = i+j;
            if (addr>length-1) {
                fprintf(f, "      ");
            } else if (addr==length-1) {
                fprintf(f, "0x%02X  ", part[addr] );
            } else {
                fprintf(f, "0x%02X, ", part[addr] );
            }
        }
        fprintf(f, " // |");
        for (size_t j=0; j<16; j++) {
            size_t addr = i+j;
            uint8_t c = part[addr];
            if (c<32 || c>126) c = '.';
            if (addr>length-1) {
                //fputc(' ', f);
            } else {
                fputc(c, f);
            }
        }
        fprintf(f, "|\n");
    }
    fprintf(f, "};\n\n");
    fprintf(f, "size_t %s%d_size = %d;\n\n", fname, ix, length);
    ::fclose(f);

    return 0;
}


int writePgkList(FILE *f, const char *basedir, uint32_t offset, uint32_t length)
{
    uint32_t pkglEnd = offset+length;
    uint32_t nPkg = 0;
    uint32_t totalSize = 0;

    for (;;) {
        int ret = 0;
        if (offset>=pkglEnd)
            break;
        if (strncmp((char*)gRex+offset, "package", 7)!=0) {
            printf("DumpRex: pkgl-entry %d at %d is not a package\n", nPkg, offset);
            return -1;
        }
        uint32_t size = rexGetU32(offset+28);
        totalSize += size;

        ret = relocatePkg( (uint8_t*)(gRex)+offset, rexGetU32(32)+offset, 0);
        if (ret==-1) break;

        ret = writeHexForC(basedir, "package", nPkg, ".pkg", offset, size);
        if (ret==-1) break;
        fprintf(f, "package           \"%s/%s%d.pkg\"\n", basedir, "package", nPkg);
        printf("Package %d at 0x%08X, size %d\n", nPkg, offset, size);

        offset += size;
        nPkg++;
    }
    printf("Total size of all packages is %d: 0x%08X\n", totalSize, totalSize);
    return 0;
}


int dumprex(const char *filename)
{
    char configname[2048];
    char *basedir;

    basedir = dirname(configname);
    snprintf(configname, sizeof(configname), "%s.cfg", filename);

    if (strncmp((char*)gRex, "RExBlock", 8)!=0) {
        printf("DumpRex: file \"%s\" is not a REx file\n", filename);
        return -1;
    }
    FILE *f = ::fopen(configname, "wb");
    if (!f) {
        printf("DumpRex: can't open configuration file \"%s\" for writing:\n%s\n", configname, strerror(errno));
        return -1;
    }
    fprintf(f, "// \n");
    fprintf(f, "// REx configuration file generated by DumpRex from file\n");
    fprintf(f, "// %s\n", filename);
    fprintf(f, "// \n\n");
    fprintf(f, "id                %d\n", rexGetU32(28));
    fprintf(f, "version           %d\n", rexGetU32(20));
    fprintf(f, "start             0x%08X\n", rexGetU32(32));
    fprintf(f, "manufacturer      '%.4s'\n", (char*)gRex+16);

    uint32_t nEntry = rexGetU32(36);
    //printf("I see %d entries in this REx header\n", nEntry);

    // These count the number of each type of part seen in the REx.  These are
    // (so far) the only parts that have been seen multiple times in RExes.
    uint32_t fdrv = 0;
    uint32_t FDRV = 0;
    uint32_t pad = 0;
    char *tagAsString;

    for (uint32_t i=0; i<nEntry; i++) {
        uint32_t tag = rexGetU32(i*12 + 40);
        uint32_t offset = rexGetU32(i*12 + 44);
        uint32_t length = rexGetU32(i*12 + 48);
        int ret = 0;
        tagAsString = (char*)gRex+i*12+40;

        switch (tag) {
            case 'pad ':
                ret = writeHexForC(basedir, "pad ", pad, ".bin", offset, length);
                fprintf(f, "block             '%.4s' \"%s/%s%d.bin\"\n", tagAsString, basedir, tagAsString, pad);
                pad++;
                break;
            case 'fdrv':
                ret = writeHexForC(basedir, "fdrv", fdrv, ".bin", offset, length);
                fprintf(f, "block             '%.4s' \"%s/%s%d.bin\"\n", tagAsString, basedir, tagAsString, fdrv);
                fdrv++;
                break;
            case 'FDRV':
                ret = writeHexForC(basedir, "fdrvx", FDRV, ".bin", offset, length);
                fprintf(f, "block             '%.4s' \"%s/%s%d.bin\"\n", tagAsString, basedir, "fdrvx", FDRV);
                FDRV++;
                break;
            case 'pkgl':
                ret = writePgkList(f, basedir, offset, length);
                break;
            default:
                ret = writeHexForC(basedir, tagAsString, 0, ".bin", offset, length);
                fprintf(f, "block             '%.4s' \"%s/%s%d.bin\"\n", tagAsString, basedir, tagAsString, 0);
                break;
        }
        if (ret==-1)
            break;
    }
    ::fclose(f);
    return 0;
}

int readrex(const char *filename)
{
    FILE *f = ::fopen(filename, "rb");
    if (!f) {
        printf("DumpRex: can't open file \"%s\" for reading:\n%s\n", filename, strerror(errno));
        return -1;
    } else {
        ::fseek(f, 0, SEEK_END);
        size_t size = ::ftell(f);
        ::fseek(f, 0, SEEK_SET);
        gRex = malloc(size);
        gRexSize = size;
        ::fread(gRex, size, 1, f);
        ::fclose(f);
        return 0;
    }
}

/**
 Extract the content of a NewtonOS Rex file.

 This dissects the Rex file and creates a file that lists the content, and 'C' compilable
 dumps of every module that is found. Supports multiple parts, where is is known
 that there are RExes in the wild with more than one of those parts.
 */
int main(int argc, char **argv)
{
    if (argc!=2) {
        printf("Usage: DumpRex Einstein.rex\n");
        return 30;
    } else {
        if (readrex(argv[1])==-1)
            return 30;
        dumprex(argv[1]);
    }
    return 0;
}
