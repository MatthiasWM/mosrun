
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <libgen.h>


void *gRex = nullptr;
size_t gRexSize = 0;

uint32_t rexGetU32(size_t offset)
{
    if (offset+4>gRexSize)
        return 0xFEEDFEED;
    uint32_t ret = 0;
    ret |= ((uint8_t*)gRex)[offset+0]<<24;
    ret |= ((uint8_t*)gRex)[offset+1]<<16;
    ret |= ((uint8_t*)gRex)[offset+2]<<8;
    ret |= ((uint8_t*)gRex)[offset+3];
    return ret;
}


int writeHexForC(const char *basedir, const char *fname, uint32_t ix, const char *ext, uint32_t offset, uint32_t length)
{
    char filename[2048];

    // write binary
    snprintf(filename, sizeof(filename), "%s/%s%d%s", basedir, fname, ix, ext);
    FILE *f = fopen(filename, "wb");
    if (!f) {
        printf("DumpRex: can't open binary file \"%s\" for writing:\n%s\n", filename, strerror(errno));
        return -1;
    }
    ::fwrite((uint8_t*)gRex+offset, length, 1, f);
    ::fclose(f);

    // write hexdump
    snprintf(filename, sizeof(filename), "%s/%s%d%s.cpp", basedir, fname, ix, ext);
    f = fopen(filename, "wb");
    if (!f) {
        printf("DumpRex: can't open cpp file \"%s\" for writing:\n%s\n", filename, strerror(errno));
        return -1;
    }
    fprintf(f, "//\n// Generated by DumpRex.\n//\n\n");
    fprintf(f, "const uint8_t %s%d[] = {\n", fname, ix);
    uint8_t *part = (uint8_t*)gRex + offset;
    for (size_t i=0; i<length; i+=16) {
        fprintf(f, "    ");
        for (size_t j=0; j<16; j++) {
            size_t addr = i+j;
            if (addr>length-1) {
                fprintf(f, "      ");
            } else if (addr==length-1) {
                fprintf(f, "0x%02X  ", part[addr] );
            } else {
                fprintf(f, "0x%02X, ", part[addr] );
            }
        }
        fprintf(f, " // |");
        for (size_t j=0; j<16; j++) {
            size_t addr = i+j;
            uint8_t c = part[addr];
            if (c<32 || c>126) c = '.';
            if (addr>length-1) {
                //fputc(' ', f);
            } else {
                fputc(c, f);
            }
        }
        fprintf(f, "|\n");
    }
    fprintf(f, "};\n\n");
    fprintf(f, "size_t %s%d_size = %d;\n\n", fname, ix, length);
    ::fclose(f);

    return 0;
}


int writePgkList(FILE *f, const char *basedir, uint32_t offset, uint32_t length)
{
    uint32_t pkglEnd = offset+length;
    uint32_t nPkg = 0;
    for (;;) {
        int ret = 0;
        if (offset>=pkglEnd)
            break;
        if (strncmp((char*)gRex+offset, "package", 7)!=0) {
            printf("DumpRex: pkgl-entry %d at %d is not a package\n", nPkg, offset);
            return -1;
        }
        uint32_t size = rexGetU32(offset+28);

        ret = writeHexForC(basedir, "package", nPkg, ".pkg", offset, size);
        if (ret==-1) break;
        fprintf(f, "package           \"%s/%s%d.pkg\"\n", basedir, "package", nPkg);

        offset += size;
        nPkg++;
    }
    return 0;
}


int dumprex(const char *filename)
{
    char configname[2048];
    char basedir[2048];

    snprintf(configname, sizeof(configname), "%s.cfg", filename);
    ::dirname_r(filename, basedir);

    if (strncmp((char*)gRex, "RExBlock", 8)!=0) {
        printf("DumpRex: file \"%s\" is not a REx file\n", filename);
        return -1;
    }
    FILE *f = ::fopen(configname, "wb");
    if (!f) {
        printf("DumpRex: can't open configuration file \"%s\" for writing:\n%s\n", configname, strerror(errno));
        return -1;
    }
    fprintf(f, "// \n");
    fprintf(f, "// REx configuration file generated by DumpRex from file\n");
    fprintf(f, "// %s\n", filename);
    fprintf(f, "// \n\n");
    fprintf(f, "id                %d\n", rexGetU32(28));
    fprintf(f, "version           %d\n", rexGetU32(20));
    fprintf(f, "start             0x%08X\n", rexGetU32(32));
    fprintf(f, "manufacturer      '%.4s'\n", (char*)gRex+16);
    uint32_t nEntry = rexGetU32(36);

    uint32_t fdrv = 0;
    uint32_t FDRV = 0;
    for (uint32_t i=0; i<nEntry; i++) {
        uint32_t tag = rexGetU32(i*12 + 40);
        uint32_t offset = rexGetU32(i*12 + 44);
        uint32_t length = rexGetU32(i*12 + 48);
        int ret = 0;
        switch (tag) {
            case 'fdrv':
                ret = writeHexForC(basedir, "fdrv", fdrv, ".bin", offset, length);
                fprintf(f, "block             '%.4s' \"%s/%s%d.bin\"\n", (char*)gRex+i*12+40, basedir, "fdrv", fdrv);
                fdrv++;
                break;
            case 'FDRV':
                ret = writeHexForC(basedir, "fdrvx", FDRV, ".bin", offset, length);
                fprintf(f, "block             '%.4s' \"%s/%s%d.bin\"\n", (char*)gRex+i*12+40, basedir, "fdrvx", FDRV);
                FDRV++;
                break;
            case 'pkgl':
                ret = writePgkList(f, basedir, offset, length);
                break;
            default:
                printf("DumpRex: unknown entry '%.4s' in rex file \"%s\"\n", (char*)gRex+i*12+40, configname);
                ret = -1;
                break;
        }
        if (ret==-1)
            break;
    }
    ::fclose(f);
    return 0;
}

int readrex(const char *filename)
{
    FILE *f = ::fopen(filename, "rb");
    if (!f) {
        printf("DumpRex: can't open file \"%s\" for reading:\n%s\n", filename, strerror(errno));
        return -1;
    } else {
        ::fseek(f, 0, SEEK_END);
        size_t size = ::ftell(f);
        ::fseek(f, 0, SEEK_SET);
        gRex = malloc(size);
        gRexSize = size;
        ::fread(gRex, size, 1, f);
        ::fclose(f);
        return 0;
    }
}

/**
 Extract the content of a NewtonOS Rex file.

 This dissects the Rex file and creates a file that listst the content, and 'C' compilabale
 dumps of every module that is found/ The support is limited to the files that we will
 find inside Einstein.rex. No relocations are done.
 */
int main(int argc, char **argv)
{
    if (argc!=2) {
        printf("Usage: DumpRex Einstein.rex\n");
        return 30;
    } else {
        if (readrex(argv[1])==-1)
            return 30;
        dumprex(argv[1]);
    }
    return 0;
}








